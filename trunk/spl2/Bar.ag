{
module Bar where

import CPP.Intermediate
import CPP.Visualise
import HN.Intermediate hiding(Expression,Constant,Atom,Application)
import Data.List
import HN.Intermediate

type ExpressionList  = [Expression]

}

TYPE ExpressionList = [Expression]

DATA Expression
	| Application fn : Expression arg : ExpressionList
	| Atom name : String 
	| Constant c : Const

ATTR Expression ExpressionList
	[ fqnTransformer : {(Bool -> String -> String) -> String -> String} fqn : {Bool -> String -> String}
	|
	| 
	]

ATTR Expression
	[
	|
	| sem : CppExpression
	]

ATTR ExpressionList
	[
	|
	| sem USE {:} {[]} : {[CppExpression]}
	]

SEM Expression
	| Constant
		lhs.sem = CppLiteral @c
	| Atom
		lhs.sem = CppAtom $ @lhs.fqnTransformer @lhs.fqn @name
	| Application
		fn.fqnTransformer = transformFunction
		arg.fqnTransformer = transformArgument
		lhs.sem = CppApplication @fn.sem @arg.sem


{

transformArgument fqn a =  if elem ':' aaa && not (isPrefixOf "hn::" aaa) then '&' : aaa else aaa where
				aaa = fqn False a

transformFunction fqn name = fqn True name

transformGlobal fqn name = fqn False name


fqn _ a = a

sem_Expression2 fqn expr = sem_Syn_Expression $ wrap_Expression (sem_Expression expr) 
	Inh_Expression { 
		fqnTransformer_Inh_Expression = transformGlobal
	,	fqn_Inh_Expression = fqn
	}

main = print $ sem_Expression2 fqn (Application (Atom "foo") [Atom "bar", Constant (ConstInt 2)])

}
