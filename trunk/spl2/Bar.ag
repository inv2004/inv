{
module Bar where

import CPP.Intermediate
import CPP.Visualise
import HN.Intermediate hiding(Expression,Constant,Atom,Application)
import Data.List
import HN.Intermediate
import qualified Data.Set as S

type ExpressionList  = [Expression]

}

TYPE ExpressionList = [Expression]

DATA Expression
	| Application fn : Expression arg : ExpressionList
	| Atom name : String 
	| Constant c : Const

ATTR Expression ExpressionList
	[ fqnTransformer : {(Bool -> String -> String) -> String -> String} fqn : {Bool -> String -> String}
	|
	| 
	]

ATTR Expression	[ | | sem : CppExpression ]

ATTR ExpressionList [ | | sem USE {:} {[]} : {[CppExpression]} ]

SEM Expression
	| Constant
		lhs.sem = CppLiteral @c
	| Atom
		lhs.sem = CppAtom $ @lhs.fqnTransformer @lhs.fqn @name
	| Application
		fn.fqnTransformer = transformFunction
		arg.fqnTransformer = transformArgument
		lhs.sem = CppApplication @fn.sem @arg.sem

{

transformArgument fqn a =  if elem ':' aaa && not (isPrefixOf "hn::" aaa) then '&' : aaa else aaa where
				aaa = fqn False a

transformFunction fqn name = fqn True name

transformGlobal fqn name = fqn False name


sem_Expression2 fqn expr = sem_Syn_Expression $ wrap_Expression (sem_Expression expr) 
	Inh_Expression { 
		fqnTransformer_Inh_Expression = transformGlobal
	,	fqn_Inh_Expression = fqn
	}
}


ATTR Expression [ | | atoms : {S.Set String} ]

ATTR ExpressionList [ | | atoms USE {:} {[]} : {[S.Set String]} ]

SEM Expression
	| Constant    lhs.atoms = S.empty
	| Atom        lhs.atoms = S.singleton @name
	| Application lhs.atoms = S.unions (@fn.atoms : @arg.atoms)


{

getExpressionAtoms expr = atoms_Syn_Expression $ wrap_Expression (sem_Expression expr)
	Inh_Expression { 
	}

}
