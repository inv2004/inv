{
module Bar where

import CPP.Intermediate
import CPP.TypeProducer
import CPP.Visualise
import Data.List
import HN.Intermediate
import SPL.Types
import qualified Data.Set as S
import qualified Data.Map as M
import Utils
import Debug.Trace

type ExpressionList  = [Expression]

}

TYPE ExpressionList = [Expression]

DATA Expression
	| Application fn : Expression arg : ExpressionList
	| Atom name : String
	| Constant c : Const

ATTR Expression ExpressionList
	[ fqnTransformer : {(Bool -> String -> String) -> String -> String} fqn : {Bool -> String -> String}
	|
	|
	]

ATTR Expression	[ | | sem : CppExpression ]

ATTR ExpressionList [ | | sem USE {:} {[]} : {[CppExpression]} ]

SEM Expression
	| Constant
		lhs.sem = CppLiteral @c
	| Atom
		lhs.sem = CppAtom $ @lhs.fqnTransformer @lhs.fqn @name
	| Application
		fn.fqnTransformer = transformFunction
		arg.fqnTransformer = transformArgument
		lhs.sem = CppApplication @fn.sem @arg.sem

{

transformArgument fqn a =  if elem ':' aaa && not (isPrefixOf "hn::" aaa) then '&' : aaa else aaa where
				aaa = fqn False a

transformFunction fqn name = fqn True name

transformGlobal fqn name = fqn False name


sem_Expression2 fqn expr = sem_Syn_Expression $ wrap_Expression (sem_Expression expr)
	Inh_Expression {
		fqnTransformer_Inh_Expression = transformGlobal
	,	fqn_Inh_Expression = fqn
	}
}


ATTR Expression [ | | atoms : {S.Set String} ]

ATTR ExpressionList [ | | atoms USE {:} {[]} : {[S.Set String]} ]

SEM Expression
	| Constant    lhs.atoms = S.empty
	| Atom        lhs.atoms = S.singleton @name
	| Application lhs.atoms = S.unions (@fn.atoms : @arg.atoms)


{
getExpressionAtoms expr = atoms_Syn_Expression $ wrap_Expression (sem_Expression expr)
	Inh_Expression {
	}

consMaybe Nothing value = value
consMaybe (Just x) value = x : value


}

TYPE Program = [Definition]

ATTR Program
	[
 		|
		|
		    name USE {:} {[]} : {[String]}
			freeVars USE {`S.union`} {S.empty} : {S.Set String}
			cppVarDefinition USE {`consMaybe`} {[]} : {[CppLocalVarDef]}
	]

DATA Definition
	| Definition name : String params : {[String]} value : Expression where : Program

ATTR Definition Program
	[
		fqn : {Bool -> String -> String}
		typed : C
		symTab : {M.Map String CppAtomType}
		level : Int
	|
	|
	]

ATTR Definition
	[
	|
	|
		name : String
		cppDefinition : CppDefinition
		freeVars : {S.Set String}
		cppVarDefinition : {Maybe CppLocalVarDef}
	]

{


cppDefType typed args = cppUncurryType (trace3 "AG.cppDefType" $ defType typed) args

deconstructTyped t = (case t of
	CTyped _ (CL (CL (CTyped _ (CL (CL _ (S vars2)) (K types2))) (S vars)) (K types)) -> typeMap (vars ++ vars2) (types ++ types2)
	CTyped _ (CL (CL _ (S vars)) (K types)) -> typeMap vars types
	CTyped _ (CL (CTyped _ (CL (CL _ (S vars)) (K types))) _) -> typeMap vars types
	CTyped _ (CL (CL (CL (CTyped _ (CL (CL (CTyped _ (CL (CL _ (S vars2)) (K types2))) (S vars)) (K types))) _) _) _) -> typeMap (vars ++ vars2) (types ++ types2)
	_ -> error $ "non-exhaustive patterns in deconstructTyped: " ++ show t)
	where
		typeMap vars = M.fromList . zip vars . map (\(CTyped t _) -> t)

justTyped (CTyped t _) = t

defType (CTyped t _) = t
defType (CL (CTyped t (CL _ (K argTypes))) (S _)) = TT $ (map justTyped argTypes) ++ [t]
defType t =  error $ "defType: " ++ show t

typeTemplateArgs = S.toList . typePolyVars

}

SEM Definition
	| Definition
		value.fqnTransformer = transformGlobal
		where.level = @lhs.level + 1
		loc.freeVars = (@value.atoms `S.union` @where.freeVars) `subtractSet` S.fromList @params `subtractSet` S.fromList @where.name
		lhs.freeVars = @loc.freeVars
		loc.cppDefType = cppDefType @lhs.typed @params
		lhs.cppDefinition = { CppFunctionDef {
				functionLevel           = @lhs.level
			,	functionName            = @name
			,	functionRetExpr         = @value.sem
			,	functionIsStatic        = S.null $ @loc.freeVars `subtractSet` M.keysSet @lhs.symTab
			,	functionArgs            = zipWith CppVarDecl (case @loc.cppDefType of CppTypeFunction _ argTypes -> argTypes ; _ -> []) @params
			, 	functionTemplateArgs    = typeTemplateArgs $ @loc.inferredType
			,	functionReturnType      = case @loc.cppDefType of CppTypeFunction returnType _ -> returnType ; _ -> @loc.cppDefType
			,   functionLocalVars       = @where.cppVarDefinition
			,   functionContext         = constructJust False $ CppContext {
					contextLevel    = @lhs.level
				,   contextTypeName = @name ++ "_impl"
				}
		} }
		loc.inferredType = trace4 "loc.inferredType" @lhs.typed $ defType @lhs.typed
		lhs.name = @name
		loc.isFunction = not $ null @params
		lhs.cppVarDefinition = constructJust @loc.isFunction $ CppVar (cppType @loc.inferredType) @name @value.sem
