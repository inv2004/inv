{
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
module Bar (compile, Inh_Definition(..), instantiateLibrary) where

import CPP.Intermediate
import CPP.TypeProducer
import CPP.Visualise
import Data.List
import HN.Intermediate
import SPL.Types
import qualified Data.Set as S
import qualified Data.Map as M
import Utils
import SPL.Visualise
import SPL.Top
import Test.HUnit
import Debug.Trace

type ExpressionList  = [Expression]

compile self inh = cppDefinition_Syn_Definition $ wrap_Definition (sem_Definition self) inh

instantiateLibrary m = M.map (\x -> TLib x) m
}


WRAPPER Definition

TYPE ExpressionList = [Expression]

DATA Expression
	| Application fn : Expression arg : ExpressionList
	| Atom name : String
	| Constant c : Const

ATTR Expression ExpressionList
	[ fqnTransformer : {(Bool -> String -> String) -> String -> String} fqn : {Bool -> String -> String}
	|
	|
	]

ATTR Expression	[ | | sem : CppExpression ]

ATTR ExpressionList [ | | sem USE {:} {[]} : {[CppExpression]} ]

SEM Expression
	| Constant
		lhs.sem = CppLiteral @c
	| Atom
		lhs.sem = CppAtom $ @lhs.fqnTransformer @lhs.fqn @name
	| Application
		fn.fqnTransformer = transformFunction
		arg.fqnTransformer = transformArgument
		lhs.sem = CppApplication @fn.sem @arg.sem

{

transformArgument fqn a =  if elem ':' aaa && not (isPrefixOf "hn::" aaa) && not (isPrefixOf "ff::" aaa) then '&' : aaa else aaa where
				aaa = fqn False a

transformFunction fqn name = fqn True name

}

ATTR Expression [ | | atoms : {S.Set String} ]

ATTR ExpressionList [ | | atoms USE {:} {[]} : {[S.Set String]} ]

SEM Expression
	| Constant    lhs.atoms = S.empty
	| Atom        lhs.atoms = S.singleton @name
	| Application lhs.atoms = S.unions (@fn.atoms : @arg.atoms)

{

consMaybe Nothing value = value
consMaybe (Just x) value = x : value

}

TYPE Program = [Definition]

ATTR Program
	[
 		|
		|
		    name USE {:} {[]} : {[String]}
			freeVars USE {`S.union`} {S.empty} : {S.Set String}
			cppVarDefinition USE {`consMaybe`} {[]} : {[CppLocalVarDef]}
			varsFreeInFunctions USE {`S.union`} {S.empty} : {S.Set String}
			templateArgs USE {`S.union`} {S.empty} : {S.Set String}
			staticFunctionNames USE {`consMaybe`} {[]} : {[String]}
			nonStaticFunctionNames USE {`consMaybe`} {[]} : {[String]}
			contextMethods USE {`consMaybe`} {[]} : {[CppDefinition]}
	]

DATA Definition
	| Definition name : String params : {[String]} value : Expression where : Program

ATTR Definition Program
	[
		typed : C
		symTab : {M.Map String CppAtomType}
		level : Int
	|
	|
	]

ATTR Definition
	[
	|
	|
		name : String
		cppDefinition : CppDefinition
		freeVars : {S.Set String}
		cppVarDefinition : {Maybe CppLocalVarDef}
		varsFreeInFunctions : {S.Set String}
		templateArgs : {S.Set String}
		staticFunctionNames : {Maybe String}
		nonStaticFunctionNames : {Maybe String}
		contextMethods : {Maybe CppDefinition}
	]

{

symTabTranslator symTab f x = case M.lookup x symTab of
	Just (CppFqMethod prefix) -> prefix ++ "::" ++ x
	Just CppContextMethod -> if f then "impl." ++ x else "hn::bind(impl, &local::" ++ x ++ ")"
	Nothing -> x
}

SEM Definition
	| Definition
		-- òðèâèàëüíûå àòðèáóòû
		where.level = @lhs.level + 1
		lhs.name = @name
		loc.contextTypeName = @name ++ "_impl"
		loc.isFunction = not $ null @params
		loc.cppDefType = cppUncurryType @loc.inferredType @params
		lhs.contextMethods = constructJust (not @isFunction) $ @loc.cppDefinition { functionTemplateArgs = [] }
		lhs.cppVarDefinition = constructJust (@loc.isFunction) $ CppVar (cppType @loc.inferredType) @name @value.sem

		-- òîï-ôóíêöèÿ, çàìêíóòûå ïåðåìåííûå è ëîêàëüíûå ôóíêöèè
		lhs.cppDefinition = @loc.cppDefinition
		loc.cppDefinition = { CppFunctionDef {
				functionLevel           = @lhs.level
			,	functionName            = @name
			,	functionRetExpr         = @value.sem
			,	functionIsStatic        = @loc.isFunctionStatic
			,	functionArgs            = zipWith CppVarDecl (case @loc.cppDefType of CppTypeFunction _ argTypes -> argTypes ; _ -> []) @params
			, 	functionTemplateArgs    = S.toList @loc.templateArgs
			,	functionReturnType      = case @loc.cppDefType of CppTypeFunction returnType _ -> returnType ; _ -> @loc.cppDefType
			,   functionLocalVars       = localVars
			,   functionContext         = constructJust ( not ( not (null @where.contextMethods) && noUnusedTemplateContext)) $ CppContext {
					contextLevel    = @lhs.level
				,   contextTypeName = @loc.contextTypeName
				-- ïåðåìåííûå êîíòåêñòà - ýòî
				-- àðãóìåíòû ãëàâíîé ôóíêöèè, ñâîáîäíûå â where-ôóíêöèÿõ
				-- ëîêàëüíûå ïåðåìåííûå, ñâîáîäíûå â where-ôóíêöèÿõ
				,   contextVars         = @loc.contextVars ++ contextVars
				,   contextTemplateArgs = @loc.contextTemplateArgs
				,   contextMethods      = @where.contextMethods
				}
		} where
			(contextVars, localVars) = partition (\(CppVar _ name _) -> S.member name @where.varsFreeInFunctions) @where.cppVarDefinition
			noUnusedTemplateContext = True -- S.null $ S.fromList @loc.contextTemplateArgs `subtractSet` @loc.templateArgs
		}

		-- çàìêíóòûå àðãóìåíòû òîï-ôóíêöèè è òèïîâûå àðãóìåíòû øàáëîíà
		loc.freeVars = (@value.atoms `S.union` @where.freeVars) `subtractSet` S.fromList @params `subtractSet` S.fromList @where.name
		lhs.freeVars = @loc.freeVars
		lhs.varsFreeInFunctions = if @loc.isFunction then @loc.freeVars else S.empty

		loc.inferredType = substituteType @loc.s @loc.tau

		(loc.contextVars, loc.argsTv) = { case @loc.inferredType of
			TT funList -> let isArgContext a =  S.member a @where.varsFreeInFunctions in
				unzip $ map (\(typ, x) -> (CppVar (cppType typ) x $ CppAtom x, typePolyVars typ)) $ filter (\(_, y) -> isArgContext y) $ zip (init funList) @params
			_ -> ([], []) }
		loc.templateArgs = typePolyVars @loc.inferredType
		lhs.templateArgs = @loc.templateArgs
		loc.contextTemplateArgs = S.toList $ S.unions (@where.templateArgs : @loc.argsTv)

		-- â âûðàæåíèÿõ Ñ++ îáðàùåíèå ê ñèìâîëó foo âûïîëíÿåòñÿ ìíîãèìè ñïîñîáàìè:
		-- local::foo - åñëè foo ñòàòè÷åñêàÿ ôóíêöèÿ â bar_impl
		-- impl.foo - åñëè foo ïåðåìåííàÿ â bar_impl èëè (íåñòàòè÷åñêàÿ ôóíêöèÿ, è âûïîëíÿåòñÿ å¸ âûçîâ)
		-- hn::bind(impl, &local::foo) - åñëè foo íåñòàòè÷åñêàÿ ôóíêöèÿ è âûïîëíÿåòñÿ ïåðåäà÷à å¸ ïàðàìåòðîì
		-- &local::foo - åñëè foo ñòàòè÷åñêàÿ ôóíêöèÿ è âûïîëíÿåòñÿ ïåðåäà÷à å¸ ïàðàìåòðîì
		-- foo - åñëè foo ëîêàëüíàÿ ïåðåìåííàÿ ôóíêöèè èëè ïàðàìåòð ôóíêöèè
		-- hn::foo - åñëè foo ÿâëÿåòñÿ ôóíêöèåé ñòàíäàðòíîé áèáëèîòåêè
		--
		-- Ñïîñîáû íèæå íå ðåàëèçîâàíû:
		-- ïðè êàððèðîâàíèè íåîáõîäèìî âûçûâàòü hn::curry1(&local::foo) èëè hn::curry1(impl, &local::foo)
		-- ïðè âëîæåíííîñòè çàìûêàíèé íåîáõîäèìî âìåñòî local óêàçûâàòü öåïî÷êó parent::parent::foo èëè up.up.foo
		--
		-- Äëÿ ïîääåðæêè ýòèõ ðàçíûõ îáðàùåíèé ñäåëàí ñëîé symTabTranslator, fqn, fqnTransformer
		-- fqnTransformer ïîêàçûâàåò, âûïîëíÿåòñÿ ëè îáðàùåíèå ê ôóíêöèè èëè ïåðåäà÷à å¸ ïàðàìåòðîì
		-- ò.å. îäèí è òîò æå àòîì òðàíñëèðóåòñÿ ïî-ðàçíîìó, â çàâèñèìîñòè îò òîãî, íàõîäèòñÿ
		-- îí â ïîçèöèè ôóíêöèè èëè â ïîçèöèè àðãóìåíòà
		-- èçíà÷àëüíî èç êîìïèëÿòîðà ïåðåäàåòñÿ òàáëèöà áèáëèîòå÷íûõ ñèìâîëîâ
		-- íà îñíîâå S
		loc.isFunctionStatic = S.null (@loc.freeVars `subtractSet` M.keysSet @lhs.symTab)
		lhs.staticFunctionNames = constructJust (not $ @loc.isFunction && @loc.isFunctionStatic) @name
		lhs.nonStaticFunctionNames = constructJust (not $ @loc.isFunction && not @loc.isFunctionStatic) @name
		value.fqnTransformer = transformArgument
		value.fqn = {
			symTabTranslator $ symTabWithStatics `M.union` @lhs.symTab `subtractKeysFromMap` (@params ++ map (\(CppVar _ name _ ) -> name) @where.cppVarDefinition) where
				symTabWithStatics = M.fromList $ map (\name -> (name, classPrefix)) @where.staticFunctionNames ++ map (\name -> (name, CppContextMethod)) @where.nonStaticFunctionNames where
					classPrefix = CppFqMethod $ @loc.contextTypeName ++ showTemplateArgs @loc.contextTemplateArgs
		}

{

deconstructTyped x =  case x of
	CL (CL w (S _)) (K [CTyped t tw]) -> (t, tw, w)
	CL (CL w (K [CTyped t y])) _ -> (t, y, w)
	_ -> error $ "deconstructTyped: " ++ show x

}



SEM Program
	| Cons
		(_, hd.typed, tl.typed) = deconstructTyped @lhs.typed

ATTR Definition Expression
	[
		visibleAtoms : {M.Map String T}
	|
	|
		s : {[Substitution]}
		tau : T
	]

ATTR Definition
	[
	|
	|
	]

ATTR Program Definition Expression ExpressionList
	[
		inhCounter : Int
	|
	|
		synCounter: Int
	]

ATTR Program
	[
		visibleAtoms : {M.Map String T}
	|
	|
		bottomVisibleAtoms : {M.Map String T}
		bottomS : {[Substitution]}
	]


ATTR ExpressionList
	[
		visibleAtoms : {M.Map String T}
		fnS : {[Substitution]}
		fnTau : T
	|
	|
		s : {[Substitution]}
		tau : T
	]

SEM ExpressionList
	| Cons
		hd.inhCounter = @lhs.inhCounter + 1
		tl.inhCounter = @hd.synCounter
		lhs.synCounter = @tl.synCounter
	| Nil
		lhs.synCounter = @lhs.inhCounter


SEM Definition
	| Definition
		-- arguments get fresh type variables
		(where.inhCounter, loc.argAtoms) = freshAtoms @params @lhs.inhCounter
		value.inhCounter = @where.synCounter
		lhs.synCounter = @value.synCounter

		loc.s = xtrace "Definition.s" $ @value.s ++ @where.bottomS
		lhs.tau = xtrace "Definition.tau" @loc.tau
		lhs.s = @loc.s
		loc.tau = { if null @params
			then @value.tau
			else TT $ map (\(_, beta) -> substituteType @value.s beta) @argAtoms ++ [@value.tau]
		}
		where.visibleAtoms = M.union (M.fromList @loc.argAtoms) @lhs.visibleAtoms
		value.visibleAtoms = @where.bottomVisibleAtoms

{-

Обобщение алгоритма W на случай функций многих переменных

Для двух переменных

fn arg

tau = substituteType s beta
beta = freshVar
s = (v . fn.s) . arg.s
		2
arg.visibleAtoms = substitute fn.s visibleAtoms

Для многих переменных

идет левый фолд args

s(-1) = v . fn.s
s(i) = s(i-1) . arg(i).s

tau = substituteType s beta

beta = freshVars

fntau(0) = fntau

v(i) = unify (fntau(i) (TT [substituteType arg(i).s arg(i).tau] beta(i)]



-}

SEM Expression
	| Constant
		lhs.s = []
		lhs.tau = constantType @c
		lhs.synCounter = @lhs.inhCounter
	| Atom
		lhs.s = []
		(lhs.synCounter, lhs.tau) = lookupAndInstantiate @name (xtrace "Expression.Atom.visibleAtoms" @lhs.visibleAtoms) @lhs.inhCounter
	| Application
		fn.inhCounter = @lhs.inhCounter + 1
		arg.inhCounter = @fn.synCounter
		lhs.synCounter = @arg.synCounter

		arg.visibleAtoms = xtrace "Application.visibleAtoms" $ substitute @fn.s @lhs.visibleAtoms
		arg.fnS = @fn.s
		arg.fnTau = xtrace "Application.fnTau" @fn.tau

		lhs.s = xtrace "Application.s" @arg.s
		lhs.tau = xtrace "Application.tau" @arg.tau

SEM ExpressionList
	| Cons
		loc.v = xtrace "ExpressionList.v" $ unify @lhs.fnTau $ TT [substituteType @hd.s @hd.tau, @loc.beta]
		loc.beta = tv @lhs.inhCounter

		loc.s = xtrace "ExpressionList.loc.s" $ @loc.v ++ @hd.s ++ @lhs.fnS

		tl.fnS = xtrace "ExpressionList.tl.fnS" @loc.s
		tl.fnTau = xtrace "ExpressionList.fnTau" $ substituteType @loc.s @loc.beta

		hd.visibleAtoms = xtrace "ExpressionList.visibleAtoms" @lhs.visibleAtoms
		tl.visibleAtoms = xtrace "ExpressionList.tl.visibleAtoms" $ substitute @loc.s @lhs.visibleAtoms

		lhs.s = @tl.s
	| Nil
		lhs.s = xtrace "ExpressionList.s" @lhs.fnS
		lhs.tau = xtrace "ExpressionList.tau" @lhs.fnTau

SEM Program
	| Cons
		loc.s1 = xtrace "Program.Cons.hd.s" @hd.s
		loc.tau1 = @hd.tau
		hd.visibleAtoms = xtrace "Program.hd.visibleAtoms" @lhs.visibleAtoms
		tl.visibleAtoms = substitute @loc.s1 $ (replace @hd.name (closure (substitute @loc.s1 @lhs.visibleAtoms) @loc.tau1)) @lhs.visibleAtoms
		lhs.bottomVisibleAtoms = @tl.bottomVisibleAtoms

		lhs.bottomS = xtrace "Program.bottomS" $ @loc.s1 ++ @tl.bottomS

		hd.inhCounter = @lhs.inhCounter
		tl.inhCounter = @hd.synCounter
		lhs.synCounter = @tl.synCounter
	| Nil
		lhs.bottomS = []
		lhs.bottomVisibleAtoms = xtrace "Program.bottomVisibleAtoms" @lhs.visibleAtoms
		lhs.synCounter = @lhs.inhCounter
{

freshAtoms :: [String] -> Int -> (Int, [(String, T)])

freshAtoms [] counter = (counter, [])
freshAtoms a counter = (counter + length a, zipWith (\a i -> (a, tv i)) a [counter..])

substituteType :: [Substitution] -> T -> T
substituteType [] b = b
substituteType a b = result where -- trace ("substituteType:" ++ show a ++ " ===> " ++ show result) result where
	result = substituteSingle (composeSubstitutions a) b

substituteSingle a b = substituteTypeVars  b a

ztrace m t =  trace (m ++ " = " ++ show t) t

symTrace m t = trace (m ++ " = " ++ show ( M.difference t SPL.Top.get_types)) t

substitute :: [Substitution] -> M.Map String T -> M.Map String T
substitute [] b = b
substitute a b = xtrace "substitute.result: " $ M.map (substituteType a) b

unify :: T -> T -> [Substitution]
unify a b = xtrace ("unify-trace: " ++ makeType a ++ " ~ " ++ makeType b ++ " = " ++ show c) c where
	c = xunify a b
	xunify (TT (a:at @ (_:_))) (TT (b:bt @ (_:_))) = xunify a b ++ xunify (TT at) (TT bt)

 	xunify (TT [a]) b = xunify a b
 	xunify a (TT [b]) = xunify a b

	xunify (TD a a1) (TD b b1) | a == b = concat $ zipWith xunify a1 b1
	xunify (T a) (T b) | a == b = []
	xunify (TU a) b = [M.singleton a b]
	xunify b (TU a) = [M.singleton a b]
	xunify a b = error $ "unify: " ++ show a ++ " ~ " ++ show b

closure _ b = TLib b -- temporary! must be implememted properly to support "local" polymorphism

replace k v m = M.insert k v m

-- Program.s.tau:
-- Program.s: plusX, where where2 locals14 locals4 false false2 print15 euler1 euler6 euler48 euler5
-- Program.s: locals6-1 locals6 locals7 test4 locals13 test_flip3a locals12 intfunc_simple locals11 test_flip3 io2_intfunc udp_echo_server2 flip4_hn
-- compose: natrec, polyfunc_pointer
-- loop: intfunc test2 e48 t2_identifier elist


lookupAndInstantiate :: String -> M.Map String T -> Int -> (Int, T)
lookupAndInstantiate name table counter = let t = uncondLookup name table in case t of
	TLib x -> instantiatedType x counter
	_ -> (counter, t)

tv x = TU $ "t" ++ show x

constantType x = case x of
	ConstInt _ -> T "num"
	ConstString _ -> T "string"

lookupAtom name visibleAtoms freshVar = case M.lookup name visibleAtoms of
	Nothing -> error "foo" -- $ (freshVar + 1, tv freshVar)
	Just t -> error "lookupAtom" -- instantiatedType freshVar t


xtrace a b = b

typeVars (TU a) = [a]
typeVars (TT a) = concat $ map typeVars a
typeVars (TD a b) = concat $ map typeVars b
typeVars _ = []

instantiatedTypeTest t e = TestLabel "instantiatedTypeTest" $ TestCase $ assertEqual "" e  $ makeType $ snd $ instantiatedType (libType t) 10

instantiatedTypeTests = [
		instantiatedTypeTest "print" "?t10 -> IO void"
	,	instantiatedTypeTest "bind" "IO ?t10 -> (?t10 -> IO ?t11) -> IO ?t11"
	]


libType name = uncondLookup name SPL.Top.get_types

instantiatedType :: T -> Int -> (Int, T)
instantiatedType t counter = (nextCounter, substituteTypeVars t substitutions) where
	foo = zip (nub $ typeVars t) [counter..]
   	nextCounter = counter + (length $ nub $ typeVars t)
	substitutions = M.fromList $ map (\(x,y) -> (x, tv y)) foo

composeSubstitutions a = xtrace ("composeSubstitutions: " ++ show a ++ " ====> " ++ show b) b where
	b = foldr compose M.empty a


compose x y  = M.fromList $ map m1 $ M.toList u where
	u = M.union x y
	m1 :: (String, T) -> (String, T)
	m1 (k, v) = (k, xsubst v u)
	xsubst :: T -> M.Map String T -> T
	xsubst v x = substituteTypeVars v x

substituteTypeVars t substitutions = subst t where
	subst t = case t of
		TU a -> (case M.lookup a substitutions of
			Nothing -> TU a
			Just b -> b)
		TT a -> TT $ map subst a
  		TD a b -> TD a (map subst b)
		_ -> t

type Substitution = M.Map String T


}
{

}