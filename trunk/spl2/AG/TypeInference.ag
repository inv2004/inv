-- Модуль вывода типов
ATTR Expression ExpressionList Definition Program
	[
		visibleAtoms : {M.Map String T}
		finalSubstitution : {Substitution}
		inhCounter : Int
	|
	|
		synCounter: Int
	]

ATTR Definition Expression ExpressionList
	[
	|
	|
		s : {Substitution}
		tau : T
	]

ATTR Program
	[
	|
	|
		s USE {`composeSubstitutions`} {M.empty} : Substitution
	]

ATTR Definition
	[
	|
	|
		inferredType : T
	]



ATTR Program
	[
	|
	|
		bottomVisibleAtoms : {M.Map String T}
	]


ATTR ExpressionList
	[
		fnTau : T
	|
	|
	]

SEM ExpressionList
	| Cons
		hd.inhCounter = @lhs.inhCounter + 1
		tl.inhCounter = @hd.synCounter
		lhs.synCounter = @tl.synCounter
	| Nil
		lhs.synCounter = @lhs.inhCounter


SEM Definition
	| Definition
		-- arguments get fresh type variables
		(where.inhCounter, loc.argAtoms) = freshAtoms @params @lhs.inhCounter
		value.inhCounter = @where.synCounter
		lhs.synCounter = @value.synCounter

		loc.s = xtrace "Definition.s" $ @value.s `composeSubstitutions` @where.s
		lhs.tau = xtrace "Definition.tau" @loc.tau
		lhs.s = @loc.s
		loc.tau = { if null @params
			then @value.tau
			else TT $ map snd  @argAtoms ++ [@value.tau]
		}
		where.visibleAtoms = M.union (M.fromList @loc.argAtoms) @lhs.visibleAtoms
		value.visibleAtoms = @where.bottomVisibleAtoms

		-- inferredType используется алгоритмом W _ДО_ того, как создается finalSubstitution
		loc.inferredType = uncurryType @params $ closure (substituteEnv @loc.s @lhs.visibleAtoms) $ substituteType @loc.tau @loc.s
		lhs.inferredType =  @loc.inferredType

		-- definitionType - "исправленные" типы, содержащих
		-- non-generic type variables (термин Карделли)
		-- такие "необобщенные типовые переменные" возникают, если в результате
		-- анализа тела определения получается, что свободная переменная может
		-- иметь любой тип:
		-- let x = 2 in y = i
		-- для терма "i" алгоритм W выводит _МОНОТИП_ вида t324, где t324 - свободная
		-- типовая переменная. В противоположность политипу вида forall t324 . t324,
		-- в котором t324 - связанная типовая переменная
		--
		-- связывание типовых переменных с помощью квантификатора выполняет функция
		-- closure (термин Милнера), принимающая тип и типовое окружение и
		-- возвращающая тип, в котором некоторые типовые переменные квантифицированы
		--
		-- По историческим причинам вместо явных кванторов forall используются два вида
		-- типовых переменных - TV для неквантифицированных и TU для квантифицированных
		-- (описано в SPL.Types.T). Благо из-за shallow types квантор может находиться
		-- только в одном месте - в начале политипа
		--
		-- TU используются очень ограниченно - в MilnerTools.closure создаются, а в
		-- MilnerClosure.instantiatedType уничтожаются (introduction/elimination)

		loc.definitionType = xtrace ("Definition." ++ @name ++ ".finalType") $ substituteType @loc.inferredType @lhs.finalSubstitution


SEM Expression
	| Constant
		lhs.s = M.empty
		lhs.tau = constantType @c
		lhs.synCounter = @lhs.inhCounter
	| Atom
		lhs.s = M.empty
		lhs.tau = @loc.tau
		(lhs.synCounter, loc.tau) = lookupAndInstantiate @name (xtrace "Expression.Atom.visibleAtoms" @lhs.visibleAtoms) @lhs.inhCounter

		-- дополнительно к Милнеровским s и tau, вычисляются
		-- * definitionType - тип атома в месте определения
		-- * callSiteType - тип атома в месте использования
		-- Унификацией этих типов можно найти фактические шаблонные
		-- аргументы
		-- Например:
		-- print имеет в месте определения   inferredType =   a -> IO void,
 		-- а в некотором месте использования callSiteType = int -> IO void.
 		--
		-- Унификацией этих типов можно найти значение a в месте использования,
 		-- и явно указать его шаблонным аргументом: print<int>(2 + x), если
		-- это требует система типов С++ ("компилятор С++ не может вывести тип").
		--

		loc.templateArgs = { map fs $ S.toList $ typeTu definitionType where
			fs x = uncondLookup x subst
 			subst = unify definitionType callSiteType
			callSiteType = substituteType (xtrace "Atom.tau" @loc.tau) @lhs.finalSubstitution
			definitionType = xtrace "Atom.definitionType" $ tracedUncondLookup "Atom.definitionType" @name @lhs.definitionTypes
		}

	| Application
		fn.inhCounter = @lhs.inhCounter
		arg.inhCounter = @fn.synCounter
		lhs.synCounter = @arg.synCounter

		arg.fnTau = xtrace "Application.fnTau" @fn.tau

		lhs.s = xtrace "Application.s" @arg.s `composeSubstitutions` @fn.s
		lhs.tau = xtrace "Application.tau" @arg.tau

SEM ExpressionList
	| Cons
		loc.beta = tv @lhs.inhCounter

		lhs.s = @tl.s `composeSubstitutions` (unify @lhs.fnTau $ TT [substituteType @hd.tau @hd.s, @loc.beta]) `composeSubstitutions` @hd.s
		tl.fnTau = @loc.beta

	| Nil
		lhs.s = M.empty
		lhs.tau = @lhs.fnTau

SEM Program
	| Cons
		tl.visibleAtoms = M.insert @hd.name @hd.inferredType @lhs.visibleAtoms

		hd.inhCounter = @lhs.inhCounter
		tl.inhCounter = @hd.synCounter
		lhs.synCounter = @tl.synCounter
	| Nil
		lhs.bottomVisibleAtoms = xtrace "Program.bottomVisibleAtoms" @lhs.visibleAtoms
		lhs.synCounter = @lhs.inhCounter
