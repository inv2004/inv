-- Модуль вывода квалификаторов

-- квалификатор определения вычисляется на основе квалификаторов
-- свободных переменных определения
-- квалификатор атома - это "путь" к атому. Соответственно, относительные
-- пути к одному и тому же атому из разных мест различны.


ATTR Definition
	[ | | qualifier : CppQualifier ]

-- квалификатор в выражении в конце программы
ATTR LetIn
	[ localVars : {M.Map String CppQualifier} | | qualifiers : {M.Map String CppQualifier} ]


-- qualifiers - "окончательный" набор квалификаторов.
-- Для определения - это квалификаторы атомов, видимых из определения
-- Для программы - это квалификаторы атомов, видимых из данного
-- места определения. Программы имеют семантику let..in - то есть,
-- в последующих определениях из программы можно использовать
-- предыдущие. Соответственно, при проходе программы qualifiers
-- нужно непрерывно пополнять

ATTR Definition LetIn Expression ExpressionList
	[ qualifiers : {M.Map String CppQualifier} | | ]

SEM LetIn
	| Let
		-- .. и пополняем! Сначала для where-определений
		tl.qualifiers = M.insert @hd.name @hd.qualifier @lhs.qualifiers
	| In
		-- в значении определения видны как параметры определения (но уже
		-- в виде CppArgument!), так и where-определения
		value.qualifiers = xtrace "LetIn.In.qualifiers" $ M.union @lhs.localVars @lhs.qualifiers
		lhs.qualifiers = @lhs.qualifiers

SEM Definition
	| Definition
		-- В локальных определениях дополнительно видны параметры определения. Вдобавок, вложенные
		-- функции находятся "ниже" текущей, поэтому квалификаторы надо
		-- "спустить вниз" (удлиннить относительные пути):
 		-- В локальных определениях параметры "верхнего" определения видны как CppUpperArgument:
		-- В значении определения параметры определения видны как CppArgument:
		-- В значении определения локальные определения видны по-другому, чем в локальных
		-- определениях:
		loc.xqualifiers = M.map moveQualifierDown @lhs.qualifiers

		where.qualifiers = M.union (M.fromList $ zip @params $ repeat CppArgument) @loc.xqualifiers

		-- в значении определения видны как параметры определения (но уже
		-- в виде CppArgument!), так и where-определения
		loc.valueQualifiers = M.union @loc.localVars @where.qualifiers

		loc.localVars = { M.fromList $ map (\x -> (x, CppLocal)) $ S.toList $ allWhereVars S.\\ @where.varsFreeInFunctions where
			allWhereVars = S.fromList $ map (\(CppVar _ name _ ) -> name) @where.cppVarDefinition
		}

		where.localVars = @loc.localVars

		loc.foo = \f -> isJust $ find (\x -> f $ uncondLookup x @loc.valueQualifiers) $ S.toList $ @loc.freeVars
		lhs.declareSelf = @loc.foo  $ \x -> case x of CppCurrentClassMethod -> True ; CppCurrentClassMethodStatic -> True ; _ -> False
		lhs.declareParent = @loc.foo $ \x -> case x of CppParentVar -> True ; _ -> False

		loc.isFunctionStatic = { (isNothing $ find nonStaticReference $ M.elems $ M.intersectionWith (\a b -> a) @loc.valueQualifiers freeVarsMap) where
			freeVarsMap = M.fromList $ map (\x -> (x, ())) $ S.toList @loc.freeVars
		}
		lhs.qualifier = { if @loc.isFunction
			then (if @loc.isFunctionStatic
				then CppContextMethodStatic
				else CppContextMethod)
			else CppContextVar
		}
