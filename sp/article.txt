Анализ синтаксиса и логики програмирования на языках APL,LISP,Haskell

Программа в APL представляет из себя stream, данные данные при прохождении
каждого этапа передаются на вход функции, и выдаются изменённые на выходе,
после чего сразу принимаются другой функцией.
например:
+/50<{x*x}'10 _draw 10
читаем справа налево: выполнить _draw с параметром 10 (то что перед _draw для
числа 10. на выходе будет список, например
7 9 4 7 8 8 3 9 9 4.
сделать map c функцией {x*x} для списка на входе.
49 81 16 49 64 64 9 81 81 16
сравнить все элементы с 50, и обозначить как 1, те которые больше, остальные
как 0.
0 1 0 0 1 1 0 1 1 0
применить foldr с функцией + по другому можно обозначить как {x+y} для списка.
результат в итоге
5

тоже самое написанное на подобии lisp'а
(/ + (< 50 (' (lambda x*x) (_draw 10 10))))

если обозначить например << - как команду для передачи данных по-потоку то
получится:
(/ + << < 50 << ' (lambda x*x) << _draw 10 << 10
?можно как-нибудь передать на вход 2 потока?
может так ?
(+ >> / <<50 >> < << (lambda x*x)>>'<<10>>_draw<<10)
тут тогда надо иметь ввиду, что приоритет имеет поток направо.
по сути если убрать << и >>, то получится просто apl синтаксис, то есть имеет
вид:
параметры имя_функции поток



1) функции в которых больше 2х параметров ?
первые параметры задаются перед функцией, последний - после.

2) функции в которые неявно какой параметр является входящим потоком.?

{(x+y)*2} f x_points y_points


------------
стоит разделить входящий и выходящий поток.
думаю что несколько входящих потоков можно представить как один, но заключённый в pair.
так же и с выходящими потоками.

является ли временный аргумент функции потоком - нет. так как он не
используется при дальнейшем движении по потоку, в случаее необходимости его
повторного использования этот аргумент должен быть инкапсулирован в поток.
примитивные функции применяются только с аргументами, которые нельзя
инкапсулировать в поток.

------------
значит что у нас определено:
f1 p1 p2 , f2 p1, f3 p1 p2
add 1 2






