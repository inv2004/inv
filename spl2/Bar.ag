{
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
module Bar (compile2, Inh_Root(..)) where

import CPP.Intermediate
import CPP.TypeProducer
import CPP.BackendTools

import HN.Intermediate
import SPL.Types
import qualified Data.Set as S
import qualified Data.Map as M
import Data.List
import Data.Maybe
import Utils

-- UNUSED import CPP.Visualise
import Debug.Trace
-- UNUSED import SPL.Visualise


import MilnerTools

type ExpressionList  = [Expression]

compile2 def inh = cppDefinition_Syn_Root $ wrap_Root (sem_Root (Root def)) inh
}


WRAPPER Root

TYPE ExpressionList = [Expression]

DATA Root
	| Root def : Definition

ATTR Root
	[
		library : {M.Map String T}
	|
	|
		cppDefinition : CppDefinition
	]

SEM Root
	| Root
		def.level = 0
		def.inhCounter = 0
		def.visibleAtoms = @lhs.library
		def.inferredTypes = @lhs.library
		def.inferredQualifiers = M.map (const $ CppFqMethod "ff") @lhs.library
		def.neighborQualifiers = M.map (const $ CppFqMethod "ff") @lhs.library
		def.finalSubstitution = xtrace "Root.finalSubstitution" $ composeSubstitutions @def.s
		def.parent = "OH,PARENT (ASSERTION)"

DATA Expression
	| Application fn : Expression arg : ExpressionList
	| Atom name : String
	| Constant c : Const

-- Модуль построения выражений С++ из выражений HN0 и информации о типах,
-- собранной FFI и модулем вывода типов
--
-- В С++ символ имеет разный синтаксис
-- в зависимости как от вида символа, так и от позиции в выражении (позиция
-- функции и позиция аргумента)
--
-- @atomTransformer - функция отображения символа, вместо флага позиции +
-- ветвления по нему используются две функции - CPP.BackendTools.transformFunction и
-- CPP.BackendTooks.transformArgument
--
-- @inferredQualifiers - для каждого символа указан его вид. Информация о видах собирается
-- FFI и модулем компиляции замыканий
--
-- @inferredTypes - выведенные типы символов


ATTR Expression ExpressionList
	[
		atomTransformer : {M.Map String CppAtomType -> String -> T -> M.Map String T -> String -> String}
		inferredQualifiers : {M.Map String CppAtomType}
		inferredTypes : {M.Map String T}
	|
	|
	]

ATTR Expression	[  | | sem : CppExpression ]

ATTR ExpressionList [ | | sem USE {:} {[]} : {[CppExpression]} ]

SEM Expression
	-- в С++ нет дифференциации литералов по типам, и литералы могут быть
 	-- только на позиции аргумента, поэтому никакой трансляции не
	-- требуется
	| Constant
		lhs.sem = CppLiteral @c
		loc.inferredType = undefined
	-- Атомы транслируются в символы
	--
	| Atom
		-- Конструированием символа С++ из атома HN0 занимаются две функции из
		-- модуля CPP.BackendTools
		--
		-- НЕУКЛЮЖЕСТЬ
		-- Функции CPP.BackendTools.transformFunction и CPP.BackendTooks.transformArgumentФункции
		-- непосредственно конструируют строковое представление атома в С++ вместо
		-- конструирования абстрактного представления и делегации десериализации в строку
		-- инстансу Show CppExpression из модуля CPP.Visualise
		--
		lhs.sem = CppAtom $  @lhs.atomTransformer @lhs.inferredQualifiers @name @loc.callSiteType @lhs.visibleAtoms @loc.templateArgs

		loc.callSiteType = xtrace "Atom.callSiteType" $ substituteTypeVars (xtrace "Atom.tau" @loc.tau) @lhs.finalSubstitution
		loc.templateArgs = let fs = xsubstitute @loc.xsubst in makeArgs $ map fs  $ S.toList $ typePolyVars $ @loc.inferredType

		loc.inferredType = xtrace "Atom.inferredType" $ tracedUncondLookup "Atom.inferredType" @name @lhs.inferredTypes
		loc.xsubst = xtrace "Atom.xsubst" $ unify @loc.inferredType @loc.callSiteType


	| Application
		-- аппликация транслируется тоже тривиально
		-- для функции и аргумента выставляются соответствующие ФВП обработки
		fn.atomTransformer = transformFunction
		arg.atomTransformer = transformArgument
		lhs.sem = CppApplication @fn.sem @arg.sem

-- унаследованный @inferredTypes - это информация об атомах, видимых в where и value
-- данного Definition
-- синтезированный @inferredTypes - это информация о текущем атоме, передаваемая наверх
-- в узел Program для агрегации и последующей передачи в узел @Definition.where : Expression
--
ATTR Definition Program
	[
		inferredTypes : {M.Map String T}
		finalSubstitution : {Substitution}
	|
	|
	]

ATTR Definition [  | | inferredTypesS : {(String, T)} ]

-- Узел Program просто пересылает эти атрибуты - копирует и агрегирует соответственно

ATTR Program [ | | inferredTypesS : {M.Map String T} ]

SEM Program
	| Cons
		tl.inferredTypes = M.insert (fst @hd.inferredTypesS) (snd @hd.inferredTypesS)  @lhs.inferredTypes
	| Nil
		lhs.inferredTypesS = @lhs.inferredTypes

SEM Definition
	| Definition
		-- НЕУКЛЮЖЕСТЬ
		-- унаследованный @inferredTypes "спускается" Definition -> Program -> Value
		-- но из-за того, что у нас where, а не let-in, этому спуску соответствуют
		-- "нырки" в следующих двух строках:
		where.inferredTypes = @lhs.inferredTypes
		value.inferredTypes = @where.inferredTypesS

		--  собрали информацию от выводильщика и отправили всё так же "вниз"
		--	по пути  Definition -> Program -> Value, но из-за извращенного
		--	where получается сначала "наверх" в Program, затем транзитом
		-- через следующий Definition в Value
		lhs.inferredTypesS = (@name, @loc.finalType)

ATTR Expression [ | | atoms : {S.Set String} ]

ATTR ExpressionList [ | | atoms USE {:} {[]} : {[S.Set String]} ]

SEM Expression
	| Constant    lhs.atoms = S.empty
	| Atom        lhs.atoms = S.singleton @name
	| Application lhs.atoms = S.unions (@fn.atoms : @arg.atoms)

TYPE Program = [Definition]

ATTR Program
	[
 		|
		|
		    name USE {:} {[]} : {[String]}
			freeVars USE {`S.union`} {S.empty} : {S.Set String}
			cppVarDefinition USE {`consMaybe`} {[]} : {[CppLocalVarDef]}
			varsFreeInFunctions USE {`S.union`} {S.empty} : {S.Set String}
			templateArgs USE {`S.union`} {S.empty} : {S.Set String}
			contextMethods USE {`consMaybe`} {[]} : {[CppDefinition]}
			inferredQualifiersS USE {`M.union`} {M.empty} : {M.Map String CppAtomType}
			declareSelf USE {||} {False} : Bool
			declareParent USE {||} {False} : Bool
	]

DATA Definition
	| Definition name : String params : {[String]} value : Expression where : Program

ATTR Definition Program
	[
		inferredQualifiers : {M.Map String CppAtomType}
		neighborQualifiers : {M.Map String CppAtomType}
		level : Int
		parent : String
	|
	|
	]

ATTR Definition
	[
	|
	|
		name : String
		cppDefinition : CppDefinition
		freeVars : {S.Set String}
		cppVarDefinition : {Maybe CppLocalVarDef}
		varsFreeInFunctions : {S.Set String}
		templateArgs : {S.Set String}
		contextMethods : {Maybe CppDefinition}
		inferredQualifiersS : {M.Map String CppAtomType}
		declareSelf : Bool
		declareParent : Bool
	]

SEM Definition
	| Definition
		-- òðèâèàëüíûå àòðèáóòû
		where.level = @lhs.level + 1
		lhs.name = @name
		loc.contextTypeName = @name ++ "_impl"
		loc.isFunction = not $ null @params
		loc.cppDefType = xtrace "Definition.@loc.cppDefType" $ cppUncurryType @loc.finalType @params
		lhs.contextMethods = constructJust (not @isFunction) $ @loc.cppDefinition
		lhs.cppVarDefinition = constructJust (@loc.isFunction) $ CppVar (cppType @loc.finalType) @name @value.sem

		-- òîï-ôóíêöèÿ, çàìêíóòûå ïåðåìåííûå è ëîêàëüíûå ôóíêöèè
		lhs.cppDefinition = @loc.cppDefinition
		loc.cppDefinition = { CppFunctionDef {
				functionLevel           = @lhs.level
			,	functionName            = @name
			,	functionRetExpr         = @value.sem
			,	functionIsStatic        = @loc.isFunctionStatic
			,	functionArgs            = zipWith CppVarDecl (case @loc.cppDefType of CppTypeFunction _ argTypes -> argTypes ; _ -> []) @params
			, 	functionTemplateArgs    = S.toList @loc.templateArgs
			,	functionReturnType      = case @loc.cppDefType of CppTypeFunction returnType _ -> returnType ; _ -> @loc.cppDefType
			,   functionLocalVars       = localVars
			,   functionContext         = constructJust (null @where.contextMethods) $ CppContext {
					contextLevel    = @lhs.level
				,   contextTypeName = @loc.contextTypeName
				-- ïåðåìåííûå êîíòåêñòà - ýòî
				-- àðãóìåíòû ãëàâíîé ôóíêöèè, ñâîáîäíûå â where-ôóíêöèÿõ
				-- ëîêàëüíûå ïåðåìåííûå, ñâîáîäíûå â where-ôóíêöèÿõ
				,   contextVars         = @loc.contextArgs ++ contextVars
				,   contextTemplateArgs = @loc.contextTemplateArgs
				,   contextMethods      = @where.contextMethods
				,   contextDeclareSelf  = xtrace "contextDeclareSelf" @where.declareSelf
				,   contextParent   	= xtrace "contextParent" $ constructJust (not @where.declareParent) $ @lhs.parent ++ "_impl"
				}
		} where
			(contextVars, localVars) = partition (\(CppVar _ name _) -> S.member name @where.varsFreeInFunctions) @where.cppVarDefinition
		}

		lhs.declareSelf = xtrace "Definition.declareSelf" $ isJust $ find (\x -> case xtrace ("foo " ++ x) $ uncondLookup x @loc.valueInferredQualifiers of CppCurrentClassMethod -> True ; _ -> False) $ S.toList $ xtrace "declareSelf" $ M.keysSet @lhs.neighborQualifiers `S.intersection`  @loc.freeVars
		lhs.declareParent = xtrace "Definition.declareParent" $ isJust $ find (\x -> case xtrace ("foo " ++ x) $ uncondLookup x @loc.valueInferredQualifiers of CppParentVar -> True ; _ -> False) $ S.toList $ xtrace "declareParent" $ M.keysSet @lhs.neighborQualifiers `S.intersection`  @loc.freeVars
		where.parent = @name

		-- çàìêíóòûå àðãóìåíòû òîï-ôóíêöèè è òèïîâûå àðãóìåíòû øàáëîíà
		loc.freeVars = (@value.atoms `S.union` @where.freeVars) `subtractSet` S.fromList @params `subtractSet` S.fromList @where.name
		lhs.freeVars = @loc.freeVars
		lhs.varsFreeInFunctions = if @loc.isFunction then @loc.freeVars else S.empty

		(loc.contextArgs, loc.argsTv) = { case @loc.finalType of
			TT funList -> let isArgContext a =  S.member a @where.varsFreeInFunctions in
				unzip $ map (\(typ, x) -> (CppVar (cppType typ) x $ CppAtom x, typePolyVars typ)) $ filter (\(_, y) -> isArgContext y) $ zip (init funList) @params
			_ -> ([], []) }
		loc.templateArgs = typePolyVars @loc.finalType

		loc.finalType = xtrace ("Definition." ++ @name ++ ".finalType") $ substituteTypeVars @loc.inferredType @lhs.finalSubstitution
		-- шаблонные переменные контекста верхнего уровня
		lhs.templateArgs = if not @loc.isFunction then xtrace "Definition.typeTv2" $ typeAllPolyVars @loc.finalType else xtrace "Definition.typeTv" $ typeTv @loc.finalType

		loc.contextTemplateArgs = S.toList $ S.unions (@where.templateArgs : @loc.argsTv)

		-- â âûðàæåíèÿõ Ñ++ îáðàùåíèå ê ñèìâîëó foo âûïîëíÿåòñÿ ìíîãèìè ñïîñîáàìè:
		-- local::foo - åñëè foo ñòàòè÷åñêàÿ ôóíêöèÿ â bar_impl
		-- impl.foo - åñëè foo ïåðåìåííàÿ â bar_impl èëè (íåñòàòè÷åñêàÿ ôóíêöèÿ, è âûïîëíÿåòñÿ å¸ âûçîâ)
		-- hn::bind(impl, &local::foo) - åñëè foo íåñòàòè÷åñêàÿ ôóíêöèÿ è âûïîëíÿåòñÿ ïåðåäà÷à å¸ ïàðàìåòðîì
		-- &local::foo - åñëè foo ñòàòè÷åñêàÿ ôóíêöèÿ è âûïîëíÿåòñÿ ïåðåäà÷à å¸ ïàðàìåòðîì
		-- foo - åñëè foo ëîêàëüíàÿ ïåðåìåííàÿ ôóíêöèè èëè ïàðàìåòð ôóíêöèè
		-- hn::foo - åñëè foo ÿâëÿåòñÿ ôóíêöèåé ñòàíäàðòíîé áèáëèîòåêè
		--
		-- Ñïîñîáû íèæå íå ðåàëèçîâàíû:
		-- ïðè êàððèðîâàíèè íåîáõîäèìî âûçûâàòü hn::curry1(&local::foo) èëè hn::curry1(impl, &local::foo)
		-- ïðè âëîæåíííîñòè çàìûêàíèé íåîáõîäèìî âìåñòî local óêàçûâàòü öåïî÷êó parent::parent::foo èëè up.up.foo
		--
		-- Äëÿ ïîääåðæêè ýòèõ ðàçíûõ îáðàùåíèé ñäåëàí ñëîé symTabTranslator, inferredQualifiers, atomTransformer
		-- atomTransformer ïîêàçûâàåò, âûïîëíÿåòñÿ ëè îáðàùåíèå ê ôóíêöèè èëè ïåðåäà÷à å¸ ïàðàìåòðîì
		-- ò.å. îäèí è òîò æå àòîì òðàíñëèðóåòñÿ ïî-ðàçíîìó, â çàâèñèìîñòè îò òîãî, íàõîäèòñÿ
		-- îí â ïîçèöèè ôóíêöèè èëè â ïîçèöèè àðãóìåíòà
		-- èçíà÷àëüíî èç êîìïèëÿòîðà ïåðåäàåòñÿ òàáëèöà áèáëèîòå÷íûõ ñèìâîëîâ
		-- íà îñíîâå S
		loc.isFunctionStatic = { (M.null (@loc.freeVarsMap M.\\ @lhs.inferredQualifiers)) && (isNothing $ find f $ M.toList $ xtrace "ifs" $ M.intersectionWith (\a b -> a) @lhs.inferredQualifiers $ xtrace "fvm" @loc.freeVarsMap) where
				f (_, CppUpperArgument) = True
				f (_, CppContextVar) = True
				f (_, CppContextMethod) = True
				f (_, CppCurrentClassVar) = True
				f (_, CppCurrentClassMethod) = True
				f _ = False
			}

		loc.freeVarsMap = M.fromList $ map (\x -> (x, ())) $ S.toList @loc.freeVars

		loc.qualifier = { if (@loc.isFunction) then (if @loc.isFunctionStatic then CppFqMethod "local" else CppContextMethod) else CppContextVar }

		lhs.inferredQualifiersS = M.singleton @name @loc.qualifier
		value.atomTransformer = transformArgument
		loc.valueInferredQualifiers = {
			if (@loc.isFunction)
				then xxx
				else xxx
				where
					xxx = xtrace "value.inferredQualifiers" $ M.unions [
						@loc.localVars,
						M.fromList $ zip @params $ repeat CppArgument,
						xtrace "iq" @where.inferredQualifiersS,
						M.map yyy $ xtrace "nq" @lhs.neighborQualifiers
						]
					yyy x = if @loc.isFunction then zzz x else x
					zzz CppContextVar = CppCurrentClassVar
					zzz CppContextMethod = CppCurrentClassMethod
					zzz (CppFqMethod "local") = CppCurrentClassMethod
					zzz x = x
		}
		value.inferredQualifiers = @loc.valueInferredQualifiers

		loc.allWhereVars = S.fromList $ map (\(CppVar _ name _ ) -> name) @where.cppVarDefinition
		loc.localVars = M.fromList $ map (\x -> (x, CppLocal)) $ S.toList $ @loc.allWhereVars S.\\ @where.varsFreeInFunctions
		loc.argumentQualifiers = M.fromList $ zip @params $ repeat CppUpperArgument
		where.inferredQualifiers = xtrace "where.inferredQualifiers" $ M.unions [@loc.localVars, @loc.argumentQualifiers, @lhs.inferredQualifiers]
		where.neighborQualifiers = xtrace "where.neighborQualifiers" $ M.unions [@loc.localVars, @where.inferredQualifiersS, mapParent @lhs.inferredQualifiers]
{

mapParent x = M.map f x where
	f x = case x of
		CppContextVar -> CppParentVar
		CppUpperArgument -> CppParentVar
		y -> y

}

ATTR Expression ExpressionList
		[
			finalSubstitution : {Substitution}
		|
		|
		]



ATTR Definition Expression
	[
		visibleAtoms : {M.Map String T}
	|
	|
		inferredType : T
		s : {[Substitution]}
		tau : T
	]

ATTR Definition
	[
	|
	|
	]

ATTR Program Definition Expression ExpressionList
	[
		inhCounter : Int
	|
	|
		synCounter: Int
	]

ATTR Program
	[
		visibleAtoms : {M.Map String T}
	|
	|
		bottomVisibleAtoms : {M.Map String T}
		bottomS : {[Substitution]}
	]


ATTR ExpressionList
	[
		visibleAtoms : {M.Map String T}
		fnS : {[Substitution]}
		fnTau : T
	|
	|
		s : {[Substitution]}
		tau : T
	]

SEM ExpressionList
	| Cons
		hd.inhCounter = @lhs.inhCounter + 1
		tl.inhCounter = @hd.synCounter
		lhs.synCounter = @tl.synCounter
	| Nil
		lhs.synCounter = @lhs.inhCounter


SEM Definition
	| Definition
		-- arguments get fresh type variables
		(where.inhCounter, loc.argAtoms) = freshAtoms @params @lhs.inhCounter
		value.inhCounter = @where.synCounter
		lhs.synCounter = @value.synCounter

		loc.s = xtrace "Definition.s" $ composeSubstitutions (@value.s) `xcompose2` (composeSubstitutions @where.bottomS)
		lhs.tau = xtrace "Definition.tau" @loc.tau
		lhs.s = [@loc.s]
		loc.tau = { if null @params
			then @value.tau
			else TT $ map (\(_, beta) -> substituteTypeVars beta $ composeSubstitutions @value.s)  @argAtoms ++ [@value.tau]
		}
		where.visibleAtoms = M.union (M.fromList @loc.argAtoms) @lhs.visibleAtoms
		value.visibleAtoms = @where.bottomVisibleAtoms

		loc.inferredType = xtrace "Definition.@loc.inferredType" $ uncurryType @params $ closure (substitute @loc.s @lhs.visibleAtoms) (xtrace "Definition.itB4closure" $ substituteTypeVars  (xtrace "Definition.@loc.tau" @loc.tau) (xtrace ("Definition.loc.s name " ++ @name ++ ":") @loc.s ))
		lhs.inferredType =  @loc.inferredType

SEM Expression
	| Constant
		lhs.s = []
		lhs.tau = constantType @c
		lhs.synCounter = @lhs.inhCounter
	| Atom
		lhs.s = []
		lhs.tau = @loc.tau
		(lhs.synCounter, loc.tau) = lookupAndInstantiate @name (xtrace "Expression.Atom.visibleAtoms" @lhs.visibleAtoms) @lhs.inhCounter
	| Application
		fn.inhCounter = @lhs.inhCounter + 1
		arg.inhCounter = @fn.synCounter
		lhs.synCounter = @arg.synCounter

		arg.visibleAtoms = xtrace "Application.visibleAtoms" $ substitute (composeSubstitutions @fn.s) @lhs.visibleAtoms
		arg.fnS = @fn.s
		arg.fnTau = xtrace "Application.fnTau" @fn.tau

		lhs.s = xtrace "Application.s" @arg.s
		lhs.tau = xtrace "Application.tau" @arg.tau

SEM ExpressionList
	| Cons
		loc.v = xtrace "ExpressionList.v" $ [unify @lhs.fnTau $ TT [substituteTypeVars @hd.tau (composeSubstitutions @hd.s), @loc.beta]]
		loc.beta = tv @lhs.inhCounter

		loc.s = xtrace "ExpressionList.loc.s" $ @loc.v ++ @hd.s ++ @lhs.fnS

		tl.fnS = xtrace "ExpressionList.tl.fnS" @loc.s
		tl.fnTau = xtrace "ExpressionList.fnTau" $ substituteTypeVars @loc.beta $ composeSubstitutions @loc.s

		tl.visibleAtoms = xtrace "ExpressionList.tl.visibleAtoms" $ substitute (composeSubstitutions @loc.v) $ xtrace "ExpressionList.visibleAtoms" @lhs.visibleAtoms

		lhs.s = @tl.s
	| Nil
		lhs.s = xtrace "ExpressionList.s" @lhs.fnS
		lhs.tau = xtrace "ExpressionList.tau" @lhs.fnTau

SEM Program
	| Cons
		hd.visibleAtoms = xtrace "Program.hd.visibleAtoms" @lhs.visibleAtoms
		tl.visibleAtoms = substitute (composeSubstitutions @hd.s) $ M.insert @hd.name @hd.inferredType @lhs.visibleAtoms
		lhs.bottomVisibleAtoms = @tl.bottomVisibleAtoms

		lhs.bottomS = xtrace "Program.bottomS" $ @hd.s ++ @tl.bottomS

		hd.inhCounter = @lhs.inhCounter
		tl.inhCounter = @hd.synCounter
		lhs.synCounter = @tl.synCounter
	| Nil
		lhs.bottomS = []
		lhs.bottomVisibleAtoms = xtrace "Program.bottomVisibleAtoms" @lhs.visibleAtoms
		lhs.synCounter = @lhs.inhCounter
