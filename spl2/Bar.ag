{
module Bar (compile, Inh_Definition(..)) where

import CPP.Intermediate
import CPP.TypeProducer
import CPP.Visualise
import Data.List
import HN.Intermediate
import SPL.Types
import qualified Data.Set as S
import qualified Data.Map as M
import Utils
import Debug.Trace

type ExpressionList  = [Expression]

compile self inh = cppDefinition_Syn_Definition $ wrap_Definition (sem_Definition self) inh

}

TYPE ExpressionList = [Expression]

DATA Expression
	| Application fn : Expression arg : ExpressionList
	| Atom name : String
	| Constant c : Const

ATTR Expression ExpressionList
	[ fqnTransformer : {(Bool -> String -> String) -> String -> String} fqn : {Bool -> String -> String}
	|
	|
	]

ATTR Expression	[ | | sem : CppExpression ]

ATTR ExpressionList [ | | sem USE {:} {[]} : {[CppExpression]} ]

SEM Expression
	| Constant
		lhs.sem = CppLiteral @c
	| Atom
		lhs.sem = CppAtom $ @lhs.fqnTransformer @lhs.fqn @name
	| Application
		fn.fqnTransformer = transformFunction
		arg.fqnTransformer = transformArgument
		lhs.sem = CppApplication @fn.sem @arg.sem

{

transformArgument fqn a =  if elem ':' aaa && not (isPrefixOf "hn::" aaa) then '&' : aaa else aaa where
				aaa = fqn False a

transformFunction fqn name = fqn True name

}

ATTR Expression [ | | atoms : {S.Set String} ]

ATTR ExpressionList [ | | atoms USE {:} {[]} : {[S.Set String]} ]

SEM Expression
	| Constant    lhs.atoms = S.empty
	| Atom        lhs.atoms = S.singleton @name
	| Application lhs.atoms = S.unions (@fn.atoms : @arg.atoms)

{

consMaybe Nothing value = value
consMaybe (Just x) value = x : value

}

TYPE Program = [Definition]

ATTR Program
	[
 		|
		|
		    name USE {:} {[]} : {[String]}
			freeVars USE {`S.union`} {S.empty} : {S.Set String}
			cppVarDefinition USE {`consMaybe`} {[]} : {[CppLocalVarDef]}
			varsFreeInFunctions USE {`S.union`} {S.empty} : {S.Set String}
			templateArgs USE {`S.union`} {S.empty} : {S.Set String}
			staticFunctionNames USE {`consMaybe`} {[]} : {[String]}
			nonStaticFunctionNames USE {`consMaybe`} {[]} : {[String]}
			contextMethods USE {`consMaybe`} {[]} : {[CppDefinition]}
	]

DATA Definition
	| Definition name : String params : {[String]} value : Expression where : Program

ATTR Definition Program
	[
		typed : C
		symTab : {M.Map String CppAtomType}
		level : Int
	|
	|
	]

ATTR Definition
	[
		inferredType : T
	|
	|
		name : String
		cppDefinition : CppDefinition
		freeVars : {S.Set String}
		cppVarDefinition : {Maybe CppLocalVarDef}
		varsFreeInFunctions : {S.Set String}
		templateArgs : {S.Set String}
		staticFunctionNames : {Maybe String}
		nonStaticFunctionNames : {Maybe String}
		contextMethods : {Maybe CppDefinition}
	]

{

symTabTranslator symTab f x = case M.lookup x symTab of
	Just (CppFqMethod prefix) -> prefix ++ "::" ++ x
	Just CppContextMethod -> if f then "impl." ++ x else "hn::bind(impl, &local::" ++ x ++ ")"
	Nothing -> x
}

SEM Definition
	| Definition
		-- тривиальные атрибуты
		where.level = @lhs.level + 1
		lhs.name = @name
		loc.contextTypeName = @name ++ "_impl"
		loc.isFunction = not $ null @params
		loc.cppDefType = cppUncurryType @lhs.inferredType @params
		lhs.contextMethods = constructJust (not @isFunction) $ @loc.cppDefinition { functionTemplateArgs = [] }
		lhs.cppVarDefinition = constructJust (@loc.isFunction) $ CppVar (cppType @lhs.inferredType) @name @value.sem

		-- топ-функция, замкнутые переменные и локальные функции
		lhs.cppDefinition = @loc.cppDefinition
		loc.cppDefinition = { CppFunctionDef {
				functionLevel           = @lhs.level
			,	functionName            = @name
			,	functionRetExpr         = @value.sem
			,	functionIsStatic        = @loc.isFunctionStatic
			,	functionArgs            = zipWith CppVarDecl (case @loc.cppDefType of CppTypeFunction _ argTypes -> argTypes ; _ -> []) @params
			, 	functionTemplateArgs    = S.toList @loc.templateArgs
			,	functionReturnType      = case @loc.cppDefType of CppTypeFunction returnType _ -> returnType ; _ -> @loc.cppDefType
			,   functionLocalVars       = localVars
			,   functionContext         = constructJust ( not ( not (null @where.contextMethods) && noUnusedTemplateContext)) $ CppContext {
					contextLevel    = @lhs.level
				,   contextTypeName = @loc.contextTypeName
				-- переменные контекста - это
				-- аргументы главной функции, свободные в where-функциях
				-- локальные переменные, свободные в where-функциях
				,   contextVars         = @loc.contextVars ++ contextVars
				,   contextTemplateArgs = @loc.contextTemplateArgs
				,   contextMethods      = @where.contextMethods
				}
		} where
			(contextVars, localVars) = partition (\(CppVar _ name _) -> S.member name @where.varsFreeInFunctions) @where.cppVarDefinition
			noUnusedTemplateContext = S.null $ S.fromList @loc.contextTemplateArgs `subtractSet` @loc.templateArgs
		}

		-- замкнутые аргументы топ-функции и типовые аргументы шаблона
		loc.freeVars = (@value.atoms `S.union` @where.freeVars) `subtractSet` S.fromList @params `subtractSet` S.fromList @where.name
		lhs.freeVars = @loc.freeVars
		lhs.varsFreeInFunctions = if @loc.isFunction then @loc.freeVars else S.empty

		(loc.contextVars, loc.argsTv) = { case @lhs.inferredType of
			TT funList -> let isArgContext a =  S.member a @where.varsFreeInFunctions in
				unzip $ map (\(typ, x) -> (CppVar (cppType typ) x $ CppAtom x, typePolyVars typ)) $ filter (\(_, y) -> isArgContext y) $ zip (init funList) @params
			_ -> ([], []) }
		loc.templateArgs = typePolyVars @lhs.inferredType
		lhs.templateArgs = @loc.templateArgs
		loc.contextTemplateArgs = S.toList $ S.unions (@where.templateArgs : @loc.argsTv)

		-- в выражениях С++ обращение к символу foo выполняется многими способами:
		-- local::foo - если foo статическая функция в bar_impl
		-- impl.foo - если foo переменная в bar_impl или (нестатическая функция, и выполняется её вызов)
		-- hn::bind(impl, &local::foo) - если foo нестатическая функция и выполняется передача её параметром
		-- &local::foo - если foo статическая функция и выполняется передача её параметром
		-- foo - если foo локальная переменная функции или параметр функции
		-- hn::foo - если foo является функцией стандартной библиотеки
		--
		-- Способы ниже не реализованы:
		-- при каррировании необходимо вызывать hn::curry1(&local::foo) или hn::curry1(impl, &local::foo)
		-- при вложеннности замыканий необходимо вместо local указывать цепочку parent::parent::foo или up.up.foo
		--
		-- Для поддержки этих разных обращений сделан слой symTabTranslator, fqn, fqnTransformer
		-- fqnTransformer показывает, выполняется ли обращение к функции или передача её параметром
		-- т.е. один и тот же атом транслируется по-разному, в зависимости от того, находится
		-- он в позиции функции или в позиции аргумента
		-- изначально из компилятора передается таблица библиотечных символов
		-- на основе S
		loc.isFunctionStatic = S.null (@loc.freeVars `subtractSet` M.keysSet @lhs.symTab)
		lhs.staticFunctionNames = constructJust (not $ @loc.isFunction && @loc.isFunctionStatic) @name
		lhs.nonStaticFunctionNames = constructJust (not $ @loc.isFunction && not @loc.isFunctionStatic) @name
		value.fqnTransformer = transformArgument
		value.fqn = {
			symTabTranslator $ symTabWithStatics `M.union` @lhs.symTab `subtractKeysFromMap` (@params ++ map (\(CppVar _ name _ ) -> name) @where.cppVarDefinition) where
				symTabWithStatics = M.fromList $ map (\name -> (name, classPrefix)) @where.staticFunctionNames ++ map (\name -> (name, CppContextMethod)) @where.nonStaticFunctionNames where
					classPrefix = CppFqMethod $ @loc.contextTypeName ++ showTemplateArgs @loc.contextTemplateArgs
		}

{

deconstructTyped x =  case x of
	CL (CL w (S _)) (K [CTyped t tw]) -> (t, tw, w)
	CL (CL _ (K [CTyped t y])) _ -> (t, y, undefined)
	_ -> error $ "deconstructTyped: " ++ show x

}

SEM Program
	| Cons
		(hd.inferredType, hd.typed, tl.typed) = deconstructTyped @lhs.typed

{

}